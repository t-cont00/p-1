const LogViewer = ({ logData, darkMode }) => {
  const [expandedLogs, setExpandedLogs] = useState({});

  const toggleExpand = (timestamp) => {
    setExpandedLogs(prev => ({
      ...prev,
      [timestamp]: !prev[timestamp]
    }));
  };

  // Function to extract and structure log data
  const processLogs = (rawLogs) => {
    if (!rawLogs) return [];
    
    try {
      // If it's already an object (parsed JSON), use as is
      if (typeof rawLogs === 'object' && !Array.isArray(rawLogs)) {
        return [extractLogFields(rawLogs)];
      }
      
      // If it's an array, process each item
      if (Array.isArray(rawLogs)) {
        return rawLogs.map(log => extractLogFields(log));
      }
      
      // If it's a string, try to parse it
      if (typeof rawLogs === 'string') {
        try {
          const parsed = JSON.parse(rawLogs);
          return processLogs(parsed);
        } catch (e) {
          // If not JSON, try to extract fields from string
          return [extractLogFieldsFromString(rawLogs)];
        }
      }
      
      return [];
    } catch (e) {
      console.error('Error processing logs:', e);
      return [{
        timestamp: 'Error',
        severity: 'ERROR',
        message: 'Failed to process log',
        raw: rawLogs
      }];
    }
  };

  // Extract fields from a structured log object
  const extractLogFields = (log) => {
    return {
      timestamp: log.timestamp || log.metadata?.creationTimestamp || log.lastTimestamp || 'Unknown',
      severity: log.severity || log.level || 'INFO',
      message: log.message || log.reason || JSON.stringify(log),
      source: log.source?.component || log.reportingComponent || 'Unknown',
      namespace: log.involvedObject?.namespace || log.metadata?.namespace || 'Unknown',
      raw: log
    };
  };

  // Try to extract fields from a raw log string
  const extractLogFieldsFromString = (logString) => {
    try {
      // Try to find JSON part in the string
      const jsonStart = logString.indexOf('{');
      const jsonEnd = logString.lastIndexOf('}') + 1;
      if (jsonStart >= 0 && jsonEnd > jsonStart) {
        const jsonPart = logString.slice(jsonStart, jsonEnd);
        const jsonData = JSON.parse(jsonPart.replace(/'/g, '"'));
        return extractLogFields(jsonData);
      }
      
      // Fallback to simple extraction
      const timestampMatch = logString.match(/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z/) || 
                           logString.match(/\d{2}:\d{2}:\d{2}\+\d{2}:\d{2}/);
      const severityMatch = logString.match(/Severity: (\w+)/i) || 
                          logString.match(/level: (\w+)/i) || 
                          logString.match(/\[(\w+)\]/i);
      
      return {
        timestamp: timestampMatch ? timestampMatch[0] : 'Unknown',
        severity: severityMatch ? severityMatch[1] : 'INFO',
        message: logString.length > 100 ? `${logString.substring(0, 100)}...` : logString,
        source: 'Unknown',
        namespace: 'Unknown',
        raw: logString
      };
    } catch (e) {
      return {
        timestamp: 'Error',
        severity: 'ERROR',
        message: 'Failed to parse log',
        raw: logString
      };
    }
  };

  const logs = processLogs(logData);

  return (
    <div style={{
      width: '100%',
      overflowX: 'auto',
      marginTop: '10px'
    }}>
      <table style={{
        width: '100%',
        borderCollapse: 'collapse',
        fontSize: '14px',
        color: darkMode ? '#e2e8f0' : '#2d3748'
      }}>
        <thead>
          <tr style={{
            backgroundColor: darkMode ? '#2d3748' : '#edf2f7',
            borderBottom: `1px solid ${darkMode ? '#4a5568' : '#e2e8f0'}`
          }}>
            <th style={{ padding: '10px', textAlign: 'left', width: '15%' }}>Timestamp</th>
            <th style={{ padding: '10px', textAlign: 'left', width: '10%' }}>Severity</th>
            <th style={{ padding: '10px', textAlign: 'left', width: '20%' }}>Source</th>
            <th style={{ padding: '10px', textAlign: 'left', width: '15%' }}>Namespace</th>
            <th style={{ padding: '10px', textAlign: 'left', width: '30%' }}>Message</th>
            <th style={{ padding: '10px', textAlign: 'center', width: '10%' }}>Details</th>
          </tr>
        </thead>
        <tbody>
          {logs.map((log, index) => (
            <>
              <tr key={index} style={{
                borderBottom: `1px solid ${darkMode ? '#4a5568' : '#e2e8f0'}`,
                backgroundColor: darkMode ? 
                  (index % 2 ? '#1a202c' : '#2d3748') : 
                  (index % 2 ? '#f7fafc' : 'white')
              }}>
                <td style={{ padding: '10px' }}>{log.timestamp}</td>
                <td style={{ padding: '10px' }}>
                  <span style={{
                    display: 'inline-block',
                    padding: '3px 8px',
                    borderRadius: '4px',
                    backgroundColor: getSeverityColor(log.severity, darkMode),
                    color: 'white',
                    fontSize: '12px',
                    fontWeight: 'bold'
                  }}>
                    {log.severity}
                  </span>
                </td>
                <td style={{ padding: '10px' }}>{log.source}</td>
                <td style={{ padding: '10px' }}>{log.namespace}</td>
                <td style={{ padding: '10px' }}>{log.message}</td>
                <td style={{ padding: '10px', textAlign: 'center' }}>
                  <button 
                    onClick={() => toggleExpand(log.timestamp)}
                    style={{
                      background: 'none',
                      border: 'none',
                      color: darkMode ? '#cbd5e0' : '#4a5568',
                      cursor: 'pointer',
                      transform: expandedLogs[log.timestamp] ? 'rotate(90deg)' : 'rotate(0)',
                      transition: 'transform 0.2s ease'
                    }}
                  >
                    âž”
                  </button>
                </td>
              </tr>
              {expandedLogs[log.timestamp] && (
                <tr style={{
                  backgroundColor: darkMode ? '#1a202c' : '#edf2f7',
                  borderBottom: `1px solid ${darkMode ? '#4a5568' : '#e2e8f0'}`
                }}>
                  <td colSpan="6" style={{ padding: '15px' }}>
                    <pre style={{
                      margin: 0,
                      whiteSpace: 'pre-wrap',
                      wordWrap: 'break-word',
                      fontFamily: 'monospace',
                      fontSize: '13px',
                      color: darkMode ? '#cbd5e0' : '#4a5568'
                    }}>
                      {typeof log.raw === 'object' ? 
                        JSON.stringify(log.raw, null, 2) : 
                        log.raw}
                    </pre>
                  </td>
                </tr>
              )}
            </>
          ))}
        </tbody>
      </table>
    </div>
  );
};

// Updated MessageBubble to handle both markdown and logs
const MessageBubble = ({ message, darkMode }) => {
  const isLogData = typeof message.text === 'object' || 
                   (typeof message.text === 'string' && 
                    (message.text.includes('timestamp') || 
                     message.text.includes('severity') || 
                     message.text.includes('namespace')));

  const renderMarkdown = (text) => {
    if (isLogData) return '';
    
    // Original markdown rendering logic
    text = text.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="markdown-link">$1</a>');
    text = text.replace(/^\s*-\s(.*$)/gm, '<li class="markdown-li">$1</li>');
    text = text.replace(/^\s*\*\s(.*$)/gm, '<li class="markdown-li">$1</li>');
    text = text.replace(/<li.*?>/g, '<ul class="markdown-ul">$&');
    text = text.replace(/<\/li>/g, '</li></ul>');
    text = text
      .replace(/^# (.*$)/gm, `<h2 class="markdown-h2 ${darkMode ? 'dark' : ''}">$1</h2>`)
      .replace(/^## (.*$)/gm, `<h3 class="markdown-h3 ${darkMode ? 'dark' : ''}">$1</h3>`)
      .replace(/^### (.*$)/gm, `<h4 class="markdown-h4 ${darkMode ? 'dark' : ''}">$1</h4>`)
      .replace(/\*\*(.*?)\*\*/g, `<strong class="markdown-strong ${darkMode ? 'dark' : ''}">$1</strong>`)
      .replace(/\*(.*?)\*/g, `<em class="markdown-em">$1</em>`)
      .replace(/`(.*?)`/g, `<code class="markdown-code ${darkMode ? 'dark' : ''}">$1</code>`)
      .replace(/\n/g, '<br class="markdown-br" />');

    return text;
  };

  return (
    <div className={`message-container ${message.sender === 'user' ? 'user' : 'bot'}`}>
      <div
        className={`message-bubble ${message.sender === 'user' ? 'user' : 'bot'} ${darkMode ? 'dark' : ''}`}
        style={{
          padding: isLogData ? '5px' : '12px 15px',
          borderRadius: '8px',
          maxWidth: '100%',
          fontSize: '14px',
          opacity: 0,
          transform: 'translateY(10px)',
          animation: 'fadeIn 0.3s ease-out forwards',
          backgroundColor: message.sender === 'user'
            ? (darkMode ? '#2b6cb0' : '#007bff')
            : (darkMode ? '#2d3748' : '#ecf0f1'),
          color: message.sender === 'user' ? 'white' : (darkMode ? 'white' : 'black')
        }}
      >
        {isLogData ? (
          <LogViewer logData={message.text} darkMode={darkMode} />
        ) : (
          <div dangerouslySetInnerHTML={{ __html: renderMarkdown(message.text) }} />
        )}
      </div>
    </div>
  );
};
