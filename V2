#!/bin/bash

API_URL="https://server.server.abc.com/rest/api/1.0/projects/CND/repos"
AUTH_TOKEN="(Auth-token)"
LIMIT=700
START=0

# Declare an array for repositories
declare -a REPOS

# Function to check required conditions in a YAML file
function check_yaml_conditions {
    local project_name="$1"
    local file_path="$2"
    local file_url="$API_URL/$project_name/browse/$file_path"

    # Fetch file content efficiently
    file_content=$(curl -s -H "Authorization: Bearer $AUTH_TOKEN" \
        -H "Content-Type: application/json" "$file_url")

    # Check if the content contains required conditions
    if echo "$file_content" | grep -qE "requiredDuringSchedulingIgnoredDuringExecution|preferredDuringSchedulingIgnoredDuringExecution"; then
        echo "âœ… Condition available in: $file_url"
    fi
}

# Recursive function to scan .yaml files under k8s/envs/pr
function search_yaml_files {
    local project_name="$1"
    local base_path="$2"

    # Fetch folder & file list
    response=$(curl -s -H "Authorization: Bearer $AUTH_TOKEN" \
        -H "Content-Type: application/json" "$API_URL/$project_name/browse/$base_path")

    # Exit if folder not found
    if echo "$response" | grep -q "errors.*not found"; then
        echo "ðŸš« No such folder: $base_path in $project_name"
        return
    fi

    # Extract directory and file names
    items=($(echo "$response" | grep -o '"name":"[^"]*"' | sed -E 's/"name":"([^"]+)"/\1/'))

    # Process files and folders in parallel
    for item in "${items[@]}"; do
        full_path="$base_path/$item"

        # If it's a YAML file, check conditions in parallel
        if [[ "$item" =~ \.ya?ml$ ]]; then
            check_yaml_conditions "$project_name" "$full_path" &
        fi

        # If it's a directory, recursively search inside it in parallel
        if [[ ! "$item" =~ \. ]]; then
            search_yaml_files "$project_name" "$full_path" &
        fi
    done

    # Wait for all parallel jobs to finish
    wait
}

# Fetch only valid repositories (exclude common system names)
function fetch_repositories {
    START=0
    while true; do
        response=$(curl -s -H "Authorization: Bearer $AUTH_TOKEN" \
            -H "Content-Type: application/json" "$API_URL?limit=$LIMIT&start=$START")

        # Extract repository names and filter out unwanted names
        for repo_name in $(echo "$response" | grep -o '"name":"[^"]*"' | sed -E 's/"name":"([^"]+)"/\1/'); do
            if [[ "$repo_name" != "ssh" && "$repo_name" != "http" && "$repo_name" != "cloud_native_deploy" ]]; then
                REPOS+=("$repo_name")
            fi
        done

        # Check if it's the last page
        if echo "$response" | grep -q '"isLastPage":true'; then
            break
        fi

        # Get next start index
        START=$(echo "$response" | grep -o '"nextPageStart":[0-9]*' | sed 's/"nextPageStart"://')
    done
}

# Main execution
fetch_repositories

# Read projects from repo.txt and search in parallel
mapfile -t PROJECTS < repo.txt
echo "ðŸ” Starting search in projects..."

echo "${PROJECTS[@]}" | xargs -n 1 -P 5 -I {} bash -c 'search_yaml_files "{}" "k8s/envs/pr"'

echo "âœ… Scan complete!"
